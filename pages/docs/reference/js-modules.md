---
type: doc
layout: reference
category: "JavaScript"
title: "JavaScript Modules"
---

# JavaScript Modules

You can compile your Kotlin projects to JavaScript modules for different, popular module systems. We currently support the following configurations for JavaScript modules:

1. [Unified Module Definitions (UMD)](https://github.com/umdjs/umd), which is compatible with both *AMD* and *CommonJS*. UMD modules are also able to be executed without being imported or when no module system is present. This is the default option for the `browser` and `nodejs` targets.
2. [Asynchronous Module Definitions (AMD)](https://github.com/amdjs/amdjs-api/wiki/AMD), which is in particular
   used by the [RequireJS](https://requirejs.org/) library.
3. [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1), widely used by node.js/npm
   (`require` function and `module.exports` object)
4. Plain. Don't compile for any module system. You can access a module by its name in the global scope.

Support for [ES6 Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) is currently in development.

## Targeting the browser
 
If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the `webpackTask` configuration block. For example, to switch to CommonJS, use:
 
<div class="sample" markdown="1" mode="groovy" theme="idea" data-lang="groovy">

```groovy

kotlin {
    js {
        browser {
            webpackTask {
                output.libraryTarget = "commonjs2"
            }
        }
        binaries.executable()
    }
}

```
Webpack provides two different "flavors" of CommonJS, `commonjs` and `commonjs2`, which affect the way your declarations are made available. While in most cases, you probably want `commonjs2`, which adds the `module.exports` syntax to the generated library, you can also opt for the "pure" `commonjs` option, which implements the CommonJS specification exactly. To learn more about the difference between `commonjs` and `commonjs2`, check [here](https://github.com/webpack/webpack/issues/1114).

</div>

## Creating JavaScript libraries and Node.js files

If you are creating a library that will be consumed from JavaScript, or a Node.js file, and want to use a different module system, the instructions are slightly different.

### Choosing the target module system

To select module kind, set the `moduleKind` compiler option in the Gradle build script.

<div class="multi-language-sample" data-lang="groovy">
<div class="sample" markdown="1" mode="groovy" theme="idea" data-lang="groovy">

```groovy
compileKotlinJs.kotlinOptions.moduleKind = "commonjs"

```

</div>
</div>

<div class="multi-language-sample" data-lang="kotlin">
<div class="sample" markdown="1" mode="kotlin" theme="idea" data-lang="kotlin" data-highlight-only>

```kotlin
tasks.withType(KotlinJsCompile::class.java).named("compileKotlinJs") {
    kotlinOptions.moduleKind = "commonjs"
}
```

</div>
</div>

Available values are: `umd` (default), `commonjs`, `amd`, `plain`.

Note that this is different from adjusting `webpackTask.output.libraryTarget`. The library target changes the output _generated by webpack_ (after your code has already been compiled). `kotlinOptions.moduleKind` changes the output generated _by the Kotlin compiler_.  

In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:

<div class="sample" markdown="1" mode="kotlin" theme="idea" data-lang="kotlin" data-highlight-only>

```kotlin
kotlin {
    js {
         useCommonJs()
         // . . .
    }
}
```
</div>

## `@JsModule` annotation

To tell Kotlin that an `external` class, package, function or property is a JavaScript module, you can use `@JsModule`
annotation. Consider you have the following CommonJS module called "hello":

<div class="sample" markdown="1" theme="idea" mode="java">

``` javascript
module.exports.sayHello = function(name) { alert("Hello, " + name); }
```

</div>

You should declare it like this in Kotlin:

<div class="sample" markdown="1" theme="idea" data-highlight-only>

``` kotlin
@JsModule("hello")
external fun sayHello(name: String)
```

</div>


### Applying `@JsModule` to packages

Some JavaScript libraries export packages (namespaces) instead of functions and classes.
In terms of JavaScript, it's an object that has members that *are* classes, functions and properties.
Importing these packages as Kotlin objects often looks unnatural.
The compiler allows to map imported JavaScript packages to Kotlin packages, using the following notation:

<div class="sample" markdown="1" theme="idea" data-highlight-only>

```kotlin
@file:JsModule("extModule")
package ext.jspackage.name

external fun foo()

external class C
```

</div>

where the corresponding JavaScript module is declared like this:

<div class="sample" markdown="1" theme="idea" mode="js">

``` javascript
module.exports = {
    foo:  { /* some code here */ },
    C:  { /* some code here */ }
}
```

</div>

Important: files marked with `@file:JsModule` annotation can't declare non-external members.
The example below produces compile-time error:

<div class="sample" markdown="1" theme="idea" data-highlight-only>

```kotlin
@file:JsModule("extModule")
package ext.jspackage.name

external fun foo()

fun bar() = "!" + foo() + "!" // error here
```

</div>

### Importing deeper package hierarchies

In the previous example the JavaScript module exports a single package.
However, some JavaScript libraries export multiple packages from within a module.
This case is also supported by Kotlin, though you have to declare a new `.kt` file for each package you import.

For example, let's make our example a bit more complicated:

<div class="sample" markdown="1" theme="idea" mode="js">

``` javascript
module.exports = {
    mylib: {
        pkg1: {
            foo: function() { /* some code here */ },
            bar: function() { /* some code here */ }
        },
        pkg2: {
            baz: function() { /* some code here */ }
        }
    }
}
```

</div>

To import this module in Kotlin, you have to write two Kotlin source files:

<div class="sample" markdown="1" theme="idea" data-highlight-only>

```kotlin
@file:JsModule("extModule")
@file:JsQualifier("mylib.pkg1")
package extlib.pkg1

external fun foo()

external fun bar()
```
</div>

and

<div class="sample" markdown="1" theme="idea" data-highlight-only>

```kotlin
@file:JsModule("extModule")
@file:JsQualifier("mylib.pkg2")
package extlib.pkg2

external fun baz()
```

</div>

### `@JsNonModule` annotation

When a declaration has `@JsModule`, you can't use it from Kotlin code when you don't compile it to a JavaScript module.
Usually, developers distribute their libraries both as JavaScript modules and downloadable `.js` files that you
can copy to project's static resources and include via `<script>` element. To tell Kotlin that it's ok
to use a `@JsModule` declaration from non-module environment, you should put `@JsNonModule` declaration. For example,
given JavaScript code:

<div class="sample" markdown="1" theme="idea" mode="js">

``` javascript
function topLevelSayHello(name) { alert("Hello, " + name); }
if (module && module.exports) {
    module.exports = topLevelSayHello;
}
```

</div>

can be described like this:

<div class="sample" markdown="1" theme="idea" data-highlight-only>

```kotlin
@JsModule("hello")
@JsNonModule
@JsName("topLevelSayHello")
external fun sayHello(name: String)
```

</div>

### Automatic external declaration generation with Dukat
[Dukat](https://github.com/kotlin/dukat) is a tool currently in development which allows the automatic conversion of TypeScript declaration files (`.d.ts`) into Kotlin external declarations. This aims to makes it more comfortable to use libraries from the JavaScript ecosystem in a type-safe manner in Kotlin, reducing the need for manually writing wrappers for JS libraries.

**Please note that Dukat is still experimental.** If you encounter any problems, please report them in Dukat's [issue tracker](https://github.com/kotlin/dukat/issues).

The Kotlin/JS Gradle plugin provides an integration with Dukat. When enabled, typesafe wrappers are automatically generated for npm dependencies and can be used from Kotlin. You have two different ways of selecting if and when Dukat should generate declarations: at build time, and manually via a Gradle task.

#### Generating external declarations at build time

The npm dependency function takes a third parameter after the package name and version: `generateExternals`. This allows you to control whether Dukat should generate declarations for a specific dependency:


<div class="multi-language-sample" data-lang="groovy">
<div class="sample" markdown="1" theme="idea" mode='groovy'>

```groovy
dependencies {
    implementation(npm('decamelize', '4.0.0', true))
}
```

</div>
</div>

<div class="multi-language-sample" data-lang="kotlin">
<div class="sample" markdown="1" theme="idea" mode='kotlin' data-highlight-only>

```kotlin
dependencies {
    implementation(npm("decamelize", "4.0.0", generateExternals = true))
}
```

</div>
</div>


You can use the flag `kotlin.js.generate.externals` in your `gradle.properties` file to set the generator's behavior for all npm dependencies simultaneously. As usual, individual explicit settings take precedence over this general flag.

#### Manually generating external declarations via Gradle task

If you want to have full control over the declarations generated by Dukat, want to apply manual adjustments, or if you're running into trouble with the auto-generated externals, you can also trigger the creation of the declarations for all your npm dependencies manually via the Gradle task `generateExternals`. This will generate declarations in a directory titled `externals` in your project root. Here, you can review the generated code and copy any parts you would like to use to your source directories.

Please be advised that manually providing external declarations in your source folder and enabling the generation of external declarations at build time for the same dependency can result in resolution issues.


### Notes

Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on `kotlin-stdlib-js`, it is also available on NPM as the [`kotlin`](https://www.npmjs.com/package/kotlin) package.